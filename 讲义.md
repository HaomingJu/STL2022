# C++ & STL
<!-- vim-markdown-toc GFM -->

* [1. 编译期决定/运行期决定](#1-编译期决定运行期决定)
    * [1.1 语法支持-内嵌型别](#11-语法支持-内嵌型别)
    * [1.2 特性萃取-Traits](#12-特性萃取-traits)
    * [1.3 应用-利用特性萃取实现分支判断](#13-应用-利用特性萃取实现分支判断)

<!-- vim-markdown-toc -->

## 1. 编译期决定/运行期决定

std::string & char[]

类型判断 编译期(萃取)与运行期(typeid)


### 1.1 语法支持-内嵌型别

```
struct S {
    typedef int Integer;
}

// Using
int main(int argc, char* argv[]) {
    typename S::Integer i;
    i = 1;
}
```

内嵌类型在使用时, 需要前置typename, 编译器无法区分是类型还是静态变量

### 1.2 特性萃取-Traits

```
struct __true_type {};
struct __false_type {};
```

* 判断是否为内置类型

```
template <typename T>
isBuildIn(T) {
    typedef false is_build_in;
}

template <>
isBuildIn<int>(T) {
    typedef true is_build_in;
}

template <>
isBuildIn<float>(T) {
    typedef true is_build_in;
}



#include <string>
int main(int argc, char* argv[]) {
    std::string s;
    int i;
    float f;

    isBuildIn<s>::is_build_in;
    isBuildIn<i>::is_build_in;
    isBuildIn<f>::is_build_in;
}


```



### 1.3 应用-利用特性萃取实现分支判断


* 对用户自定义类型的复制以及内置类型的复制

```
struct A {
    int i;
}
struct B {
    int* iPtr = new int[3];
    B& operator= (const B&) {
        // ...
    }

    ~B() {delete iPtr;}
}
```

我现在要统一我所有的对象的 赋值构造

```
// 对于具有平凡赋值函数的, 即可以使用内存拷贝的方式进行赋值构造 <快>
template <typename T>
__copy(T& dst, const T& src, __true_type) {
    memcpy((void*)&dst, (void*)&src, sizeof(T));
}

// 对于没有平凡赋值函数的, 只能采用定义的赋值构造函数. <慢>
template <typename T>
__copy(T& dst, const T& src, __false_type) {
    dst = src;
}

template <typename T>
copy(T& dst, const T& src) {
     typedef typename TypeTraits<T>::can_use_memcpy can_use;
     __copy(dst, src, can_use());
}
```


```

template <typename T>
struct TypeTraits {
    typedef __false_type can_use_memcpy;

}

template <>
struct TypeTraits<int> {
    typedef __true_type can_use_memcpy;
}

template <>
struct TypeTraits<A> {
    typedef __true_type can_use_memcpy;
}

template <>
struct TypeTraits<B> {
    typedef __false_type can_use_memcpy;
}

```

* 针对不同类型进行的处理
